/*
Duplicate Along Curve v2.0.1
Script written by Peter Chapman.
Email: peter@chapmanstudios.co.uk

You are welcome to use and distribute this script, however,
if you do so, send me a quick e-mail with your name and what
you used it for.

Also feel free to give me feedback / request changes.

If you end up using the script for a commercial project,
feel free to contribute via PayPal using the email address
above!
*/

// Source external scripts:
source generateChannelMenu.mel;
source "cs/csProgBar.mel";

// disable cycleCheck
cycleCheck -e off;

// Reset
global proc dacReset(){
    string $sel[] = `ls -sl`;
    string $cNode = $sel[0];

    // Check if a csDAC node is selected
    if (!`objExists ($cNode + ".csControls")`){
        confirmDialog -icn "warning" -t "ERROR" -m "This object is not a csDAC Control Node" -b "OK";
        return;
    }

    delete $cNode;
}

global proc int numCvs(string $curve){
	string $infoNode = `createNode curveInfo`;
	connectAttr ($curve + ".worldSpace")  ($infoNode + ".inputCurve");
	
	int $numCvs;
	$numCvs = `getAttr ($curve + ".degree")` + `getAttr ($curve + ".spans")`;
	// delete the curve info node
	delete $infoNode;
	return $numCvs;
}

// autoFill
global proc autoFill(){

	string $sel[] = `ls -sl`;
	string $curve;

	if (size($sel) == 0) {
		warning "Please select a curve.";
		return;
	}
	else if (size($sel) == 1){
		$curve = $sel[0];
	}
	else if (size($sel) == 2){
		$curve = $sel[1];
	}
	else {
		confirmDialog -icn "warning" -t "ERROR 1.01" -m "Too many objects selected. Please select the object to duplicate and then the curve." -b "OK";
		return;
	}

    string $shape[] = `listRelatives -s $curve`;
    if(size($shape) > 0)
    {
        string $nodeType = `nodeType $shape[0]`;
        if($nodeType != "nurbsCurve"){
            warning "Please select a NURBS curve as the last object.";
            return;
        }
    }
    else {
        warning "Please select a NURBS curve as the last object.";
        return;
    }


	floatField -e -v `numCvs($curve)` ff_dac;

	select -r $sel;
}

// Build Star Shape
global proc string makeStar(string $name){
	string $circle[] = `circle -n $name -ch 0 -o on -nr 0 0 1 -r 1 -s 16`;
	string $star = $circle[0];
	scale -r -ocp 0.25 0.25 0.25 ($star + ".cv[0]") ($star + ".cv[2]") ($star + ".cv[4]") ($star + ".cv[6]") ($star + ".cv[8]") ($star + ".cv[10]") ($star + ".cv[12]") ($star + ".cv[14]");
	setAttr -lock true -keyable false -channelBox false ($star + ".v");
	return $star;
}
// Get Data from Control Node
// Write Data to Control Node
// Build Pillars

// Main Procedure
global proc dac(int $n, int $cb_inst, int $cb_beams, int $cb_circle, int $cb_aim, int $cb_flow){

	string $sel[] = `ls -sl`;
	
	string $duplicate = "duplicate";
	if ($cb_inst == 1) $duplicate = "instance";
	
	if (size($sel) == 1){
		if (`objExists ($sel[0] + ".csControls")`) dacReset($n, $cb_inst, $cb_beams, $cb_circle, $cb_aim, $cb_flow);
		else confirmDialog -icn "warning" -t "ERROR 1.02" -m "This object is not a csDAC Control Node" -b "OK";
	}
	
	else if (size($sel) != 2) confirmDialog -icn "warning" -t "ERROR 1.01" -m "Not enough or too many objects selected." -b "OK";
	
	else {
		string $piece = $sel[0];
		string $targetCurve = $sel[1];
		
		// create Curve Control Node and Heirarchy
	
	    string $cNode = `createNode -n controlNode transform`;
	    string $curvesNode = `createNode -n curvesNode transform`;
	    string $piecesNode = `createNode -n piecesNode transform`;
	    string $locNode = `createNode -n locatorNode transform`;
		string $flowNode = `createNode -n flowNode transform`;
	    setAttr ($locNode + ".v") 0;
	
	    // SetUpControlNode
	    addAttr -ln "csControls"  -at bool  $cNode;
	    setAttr -e -channelBox true ($cNode + ".csControls") 1;
	    addAttr -ln "bank"  -at double $cNode;
	    setAttr -e -keyable true ($cNode + ".bank");
	    addAttr -ln "objScale" -at double $cNode;
		setAttr -e -keyable true ($cNode + ".objScale") 1;
		addAttr -ln "ctrlScale" -at double $cNode;
		setAttr -e -keyable true ($cNode + ".ctrlScale") 1;
		
	    setAttr -lock true -keyable false -channelBox false ($cNode + ".tx");
	    setAttr -lock true -keyable false -channelBox false ($cNode + ".ty");
	    setAttr -lock true -keyable false -channelBox false ($cNode + ".tz");
	    setAttr -lock true -keyable false -channelBox false ($cNode + ".rx");
	    setAttr -lock true -keyable false -channelBox false ($cNode + ".ry");
	    setAttr -lock true -keyable false -channelBox false ($cNode + ".rz");
	    setAttr -lock true -keyable false -channelBox false ($cNode + ".sx");
	    setAttr -lock true -keyable false -channelBox false ($cNode + ".sy");
	    setAttr -lock true -keyable false -channelBox false ($cNode + ".sz");
	    setAttr -lock true -keyable false -channelBox false ($cNode + ".v");
	    
		// Set Curve identifier
		if (!`objExists ($targetCurve + ".csDac")`){
			addAttr -ln "csDac"  -at bool  $targetCurve;
			setAttr -e -channelBox true ($targetCurve + ".csDac") 1;
	    }
		
		// Create Offset Curve for loops
	    string $t[] = `offsetCurve
	        -ch on
	        -rn false
	        -cb 2
	        -st true
	        -cl false
	        -cr 0
	        -d 0
	        -tol 0.01
	        -sd 0
	        -ugn false 
	        $targetCurve`;
		
	    string $objUpCurve = $t[0];
	    setAttr ($objUpCurve + ".ty") 1;
		
		//duplicate pieces
		string $allPieces[];
	    for ($i = 0; $i < $n; ++$i){
			
			// enable Progress Bar
			int $interrupt = progWindow($i, $n);
			if ($interrupt == 1){
				break;
			}
			
			// create uValue Override
			string $md_uValue = `createNode multiplyDivide -n ("md_csDacUValue" + $i)`;
			string $pm_uValue = `createNode plusMinusAverage -n ("pm_csDacUValue" + $i)`;
			setAttr ($md_uValue + ".input1Y") (1.000 / $n);
			setAttr ($md_uValue + ".input2Y") $i;
			connectAttr -f ($md_uValue + ".outputX") ($pm_uValue + ".input1D[0]");
			connectAttr -f ($md_uValue + ".outputY") ($pm_uValue + ".input1D[1]");
			
			// build locators for aim contstraints
			string $t[] = `spaceLocator -p 0 0 0`;
			$cLoc = `parent $t[0] $locNode`;

			// Build Path
			select -r $cLoc $objUpCurve;
			string $motionPath = `pathAnimation	-fractionMode true -follow true`;
			disconnectAttr ($motionPath +"_uValue.output") ($motionPath + ".uValue");
			connectAttr -f ($pm_uValue + ".output1D") ($motionPath + ".uValue");
	
			// Dupicate / Instance Pieces
			if ($cb_inst) $t = `instance $piece`;
	        else $t = `duplicate $piece`;
	        string $cMesh = $t[0];
			string $cc_piece = makeStar(("cc_piece" + $i));
			$allPieces[$i] = $cc_piece;
			addAttr -ln "offset" -at double $cc_piece;
			setAttr -e -keyable true ($cc_piece + ".offset") 0;
			addAttr -ln "offsetRate" -at double $cc_piece;
			setAttr -e -keyable true ($cc_piece + ".offsetRate") 0.01;
			connectAttr -f ($cc_piece + ".offset") ($md_uValue + ".input1X");
			connectAttr -f ($cc_piece + ".offsetRate") ($md_uValue + ".input2X");
			string $cc_meshScale = `group -n ("meshScale" + $i) $cMesh`;
			string $cc_ctrlScale = `group -n ("ctrlScale" + $i) $cc_piece`;
			string $cPiece = `group -n ("pieceBindNode" + $i) $cc_ctrlScale $cc_meshScale`;
			connectAttr -f ($cc_piece + ".s") ($cc_meshScale + ".s");
			parentConstraint -mo -weight 1 $cc_piece $cc_meshScale;
			connectAttr -f ($cNode + ".objScale") ($cPiece + ".sx");
			connectAttr -f ($cNode + ".objScale") ($cPiece + ".sy");
			connectAttr -f ($cNode + ".objScale") ($cPiece + ".sz");
	        connectAttr -f ($cNode + ".ctrlScale") ($cc_ctrlScale + ".sx");
	        connectAttr -f ($cNode + ".ctrlScale") ($cc_ctrlScale + ".sy");
	        connectAttr -f ($cNode + ".ctrlScale") ($cc_ctrlScale + ".sz");
			
			// Distribute Pieces along curve
	        select $cPiece $targetCurve;
	        string $motionPath = `pathAnimation
	            -fractionMode true
	            -follow true
	            -followAxis z
	            -upAxis y
	            -worldUpType "object"
	            -worldUpObject $cLoc
	            -inverseUp false
	            -inverseFront false
	            -bank true`;
	        disconnectAttr ($motionPath +"_uValue.output") ($motionPath + ".uValue");
	        connectAttr -f ($pm_uValue + ".output1D") ($motionPath + ".uValue");
	        connectAttr -f ($cNode + ".bank") ($motionPath + ".bankScale");

			// Setup Aim Constraint
			if($cb_aim == 1){
				if($i < ($n-1)){
					aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 0 1 -upVector 0 1 0 -worldUpType "object" -worldUpObject $cLoc $allPieces[$i+1] $cc_piece;
				}
				else{
					aimConstraint -offset 0 0 0 -weight 1 -aimVector 0 0 1 -upVector 0 1 0 -worldUpType "object" -worldUpObject $cLoc $allPieces[0] $cc_piece;
				}
			}
			
			// Setup Flow
			if ($cb_flow == 1){
				string $flow[] = `flow -divisions 2 2 4 -objectCentered 1 -localCompute 0 -localDivisions 2 2 2 $cPiece`;
				parent $flow[1] $flowNode;
			}
			
			// Complete Circle
			if ($cb_circle == 1){
				if ($i == ($n-1)){
					string $endCurves[] = `listRelatives -c -type "nurbsCurve" $allPieces[0]`;
					string $startCurves[] = `listRelatives -c -type "nurbsCurve" $allPieces[$i]`;

					for($c=0; $c < size($startCurves); $c++){
						attachCurve -ch 1 -rpo yes -n "beam" $startCurves[$c] $endCurves[$c];
					}
				}
			}
			
			// Cleanup
			string $t[] = `parent $cPiece $piecesNode`;
			string $cPieces = $t[0];
	   }

		//CleanUp
		parent $targetCurve $objUpCurve $curvesNode;
		parent $curvesNode $cNode;
		string $t[] = `parent $locNode $cNode`;
		string $locNode = $t[0];
		string $t[] = `parent $piecesNode $cNode`;
		string $piecesNode = $t[0];
		string $t[] = `parent $flowNode $cNode`;
		string $flowNode = $t[0];
		
		//Store Data

		addAttr -ln "piece" -dt "string" $cNode;
		setAttr -e -channelBox true -type "string" ($cNode + ".piece") $piece;
		addAttr -ln "targetCurve" -dt "string" $cNode;
		setAttr -e -channelBox true -type "string" ($cNode + ".targetCurve") ($cNode + "|" + $curvesNode + "|" + $targetCurve);
		addAttr -ln "offsetCurve" -dt "string" $cNode;
		setAttr -e -channelBox true -type "string" ($cNode + ".offsetCurve") $objUpCurve;
		addAttr -ln "locNode" -dt "string" $cNode;
		setAttr -e -channelBox true -type "string" ($cNode + ".locNode") $locNode;
		addAttr -ln "piecesNode" -dt "string" $cNode;
		setAttr -e -channelBox true -type "string" ($cNode + ".piecesNode") $piecesNode;
		addAttr -ln "flowNode" -dt "string" $cNode;
		setAttr -e -channelBox true -type "string" ($cNode + ".flowNode") $flowNode;
		
		select $cNode;
		print "Complete \n";
		addAttr -ln "pillarType"  -dt "string"  $cNode;
		setAttr -e -cb true -type "string" ($cNode + ".pillarType") "none";
		
		frameLayout -e -cl 1 fl_pillars;
		frameLayout -e -cl 1 fl_select;
	}
}

// Delete Pillars
global proc deletePillars(){
    string $sel[] = `ls -sl`;
    string $cNode = $sel[0];

    if(`objExists ($cNode + "|pillarsNode")`){
        delete ($cNode + "|pillarsNode");
    }
    setAttr -type "string" ($cNode + ".pillarType") "none";
}


// Build Pillars
global proc buildPillars(int $rate, string $style){
    string $sel[] = `ls -sl`;
    string $cNode = $sel[0];

    // Check if a csDAC node is selected
    if (!`objExists ($cNode + ".csControls")`){
        confirmDialog -icn "warning" -t "ERROR" -m "This object is not a csDAC Control Node" -b "OK";
        return;
    }

    // Delete existing pillars
    deletePillars();

    // Get required nodes from control node attributes
    string $piecesNode;
    $piecesNode = `getAttr ($cNode + ".piecesNode")`;

    string $pieces[] = `listRelatives -c $piecesNode`;
    string $pillarsNode = `group -em -n "pillarsNode"`;
    parent $pillarsNode $cNode;

    for($i=0; $i < size($pieces); $i+=$rate){
        string $piece = $pieces[$i];
        float $pos[] = `xform -q -ws -t $piece`;

        string $pillar[];
        if($style == "cylinder"){
            $pillar = `cylinder -p 0 0 0 -ax 0 1 0 -ssw 0 -esw 360 -r 1 -hr 20 -d 3 -ut 0 -tol 0.01 -s 8 -nsp 1 -ch 1`;
            move -a $pos[0] 0 $pos[2] $pillar[0];
            setAttr ($pillar[1] + ".radius") 0.5;
            setAttr ($pillar[1] + ".height") $pos[1];
        }
        else if($style == "square"){
            $pillar = `polyCube -w 1 -h 1 -d 1 -sx 1 -sy 1 -sz 1 -ax 0 1 0 -cuv 4 -ch 1`;
            move -a $pos[0] ($pos[1]/2) $pos[2] $pillar[0];
            setAttr ($pillar[1] + ".height") $pos[1];
        }
        else if($style == "overhangSquare"){
             // Create base
            $pillar = `polyCube -w 1 -h 1 -d 1 -sx 1 -sy 1 -sz 1 -ax 0 1 0 -cuv 4 -ch 1`;
            move -a $pos[0] (($pos[1] - 0.5)/2) $pos[2] $pillar[0];
            setAttr ($pillar[1] + ".height") ($pos[1] - 0.5);
             // Create overhang
            string $overhang[] = `polyCube -w 1.5 -h 0.5 -d 1.5 -sx 1 -sy 1 -sz 1 -ax 0 1 0 -cuv 4 -ch 1`;
            move -a $pos[0] ($pos[1] - 0.25) $pos[2] $overhang[0];
            $pillar[0] = `polyUnite -ch 1 -n "pillar" $pillar[0] $overhang[0]`;
        }
        else if($style == "overhangCylinder"){
            // Create base
            $pillar = `cylinder -p 0 0 0 -ax 0 1 0 -ssw 0 -esw 360 -r 0.5 -hr 20 -d 3 -ut 0 -tol 0.01 -s 8 -nsp 1 -ch 1`;
            move -a $pos[0] 0 $pos[2] $pillar[0];
            setAttr ($pillar[1] + ".height") ($pos[1] - 0.5);
             // Create overhang
            string $overhang[] = `cylinder -p 0 0 0 -ax 0 1 0 -ssw 0 -esw 360 -r 0.75 -hr 2 -d 3 -ut 0 -tol 0.01 -s 8 -nsp 1 -ch 1`;
            move -a $pos[0] ($pos[1] - 0.25) $pos[2] $overhang[0];
            $pillar[0] = `polyUnite -ch 1 -n "pillar" $pillar[0] $overhang[0]`;
        }

        parent $pillar[0] $pillarsNode;
    }

    // Store pillar type on control node
    setAttr -type "string" ($cNode + ".pillarType") $style;

    select $cNode;
}

// Get Selection
global proc getSel(string $type){
    string $sel[] = `ls -sl`;
    string $cNode = $sel[0];
    string $piecesNode;
    string $targetCurve;

    // Get required nodes from control node attributes
    $piecesNode = `getAttr ($cNode + ".piecesNode")`;
    $targetCurve = `getAttr ($cNode + ".targetCurve")`;

    if($type == "cc"){
        string $rel[] = `listRelatives -c $piecesNode`;
        string $curves[] = `listRelatives -c $rel`;
        select $curves;
    }
    else if($type == "tc"){
        select $targetCurve;
    }
}

// Make Beams
global proc makeBeams(){
    string $sel[] = `ls -sl`;
    string $cNode = $sel[0];

    string $piecesNode;
    $piecesNode = `getAttr ($cNode + ".piecesNode")`;

    string $allPieces[] = `listRelatives -c -pa $piecesNode`;

    string $curves[];
    for($piece in $allPieces){
        string $subCurves[] = `listRelatives -c -type "nurbsCurve" $piece`;
        $curves[size($curves)] = $subCurves[0];
    }

    for($i=0; $i < (size($curves) - 1); $i++){
        loft -ch 1 -u 1 -c 0 -ar 1 -d 3 -ss 1 -rn 0 -po 0 -rsn true $curves[$i] $curves[$i+1];
    }

}

// Launch DAC Help Menu
global proc dacHelpMenu(){

	source generateChannelMenu.mel;
	
    if(`window -q -ex dacHelpMenu`){
      deleteUI dacHelpMenu;
    }

    window  -s 0 -w 400 -h 500 -title "Help / About" dacHelpMenu;
    columnLayout ColumnLayout;

	scrollField
		-w 400
		-h 470
		-wordWrap true
		-editable false
		-text ("This script will take a Group of objects and duplicate them along a specified curve. "
			+ "If the group contains curves, these "
			+ "can be lofted after creation using the 'Make Beams' command. "
			+ "You can edit the shape, angle and scale of the track and "
			+ "pillars dynamically after creation. You can also change the "
			+ "pillar rate and number of duplicates at anytime by selecting "
			+ "the control node and entering a new value."
			+ "\n\n\n\n\n\n\n"
			+ "Script written by Peter Chapman.\n"
			+ "Email:  peter@chapmanstudios.co.uk"
			+ "\n\n\n\n\n\n\n"
			+ "You are welcome to use and distribute this script, however, "
			+ "if you do so, send me a quick e-mail with your name and what "
			+ "you used it for."
			+ "\n\n"
			+ "Also feel free to give me feedback / request changes. "
			+ "\n\n"
			+ "If you use the script for a commercial project, "
			+ "please contribute via PayPal using the email address "
			+ "above. ");
	
	button -w 400 -bgc 1 0.5 0 -l "CLOSE" -c "deleteUI dacHelpMenu;";
	showWindow dacHelpMenu;
	window -e -w 400 -h 500 dacHelpMenu;
}

// Main Menu:
global proc dacMenu(){

    source generateChannelMenu.mel;
	
     if(`window -q -ex dacMenu`){
      deleteUI dacMenu;
    }

    window  -s 0 -w 250 -h 300 -title "DAC" dacMenu;
    columnLayout cl_main;
		button -w 250 -bgc 0.4 0.4 0.4 -l "Help / About" -ann "Help / About" -c "dacHelpMenu()";
		frameLayout -w 250 -l "Duplicate Along Curve" -cll 0 fl_dac;
			rowLayout -nc 3 -cw3 100 50 100;
				text -l "No. Duplicates:";
				floatField -w 50 -v 10 ff_dac;
				button -w 100 -l "Auto" -ann "Select the Curve" -c "autoFill()";
			setParent ..;
			gridLayout -ch 15 -cw 125 -nc 2;
				checkBox -l "Instance" -v 1 cb_instance;
				checkBox -l "Aim Constrain" -v 0 cb_aim;
				checkBox -l "Build Nurbs Beams" -v 0 cb_beams;
				checkBox -l "Complete Circle" -v 0 cb_circle;
				checkBox -l "Flow" -v 0 cb_flow;
			setParent ..;
			button -w 250 -bgc 0 1 0 -l "Duplicate"
				-ann "Select the Group you wish to duplicate and THEN the curve"
				-c "dac(`floatField -q -v ff_dac`, `checkBox -q -v cb_instance`, `checkBox -q -v cb_beams`, `checkBox -q -v cb_circle`, `checkBox -q -v cb_aim`, `checkBox -q -v cb_flow`)";
		setParent ..;
		frameLayout -w 250 -l "Build Pillars" -cll 1 -cl 1 fl_pillars;
			columnLayout;
				rowLayout -nc 3 -cw3 100 50 100;
					text -l "No. Tracks per Pillar:";
					floatField -w 50 -v 5 ff_pillars;
					text -l "";
				setParent ..;
				text -l "";
				text -l "Select Pillar Style Below:";
				gridLayout -w 250 -cw 125 -nc 2 gl_pillars;
					button -w 125 -bgc 0 1 1 -l "Basic Cylinder" -c "buildPillars(`floatField -q -v ff_pillars`, \"cylinder\")";
					button -w 125 -bgc 0 1 1 -l "Basic Square" -c "buildPillars(`floatField -q -v ff_pillars`, \"square\")";
					button -w 125 -bgc 0 1 1 -l "Overhang Square" -c "buildPillars(`floatField -q -v ff_pillars`, \"overhangSquare\")";
					button -w 125 -bgc 0 1 1 -l "Overhang Cylinder" -c "buildPillars(`floatField -q -v ff_pillars`, \"overhangCylinder\")";
				setParent ..;
				button -w 250 -bgc 1 0.2 0.2 -l "Delete Pillars" -c "deletePillars()";
			setParent ..;
		setParent ..;
		frameLayout -w 250 -l "Select" -cll 1 -cl 1 fl_select;
			columnLayout cl_gridLoc;
				gridLayout -w 250 -cw 125 -nc 2 gl_curves;
				setParent ..;
				gridLayout -w 250 -cw 125 -nc 2;
					button -w 125 -bgc 1 1 0 -l "Control Curves" -c "getSel(\"cc\")";
					button -w 125 -bgc 1 0.5 0 -l "Target Curves" -c "getSel(\"tc\")";
				setParent ..;
			setParent ..;
		setParent ..;
	setParent ..;
	
	showWindow dacMenu;
	window -e -w 250 -h 400 dacMenu;
}

//Run Procedure
dacMenu();